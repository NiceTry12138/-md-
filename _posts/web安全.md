---
title: web安全
date: 2017-10-03 18:39:24
tags:
---
	安全问题：
	1. 用户身份被盗用
	2. 用户密码泄露
	3. 用户资料被盗取
	4. 网站数据库是否泄露
	5. 其他
	
	攻击种类：
	1. 跨站脚本攻击XSS
	2. 跨站请求伪造攻击
	3. 前端Cookies安全性
	4. 点击劫持攻击
	5. 传输过程安全问题
	6. 用户密码安全问题
	7. SQL注入攻击
	8. 信息泄露和社会工程学

	配置环境：
		1. 安装npm
		2. 安装node.js
		3. npm install nodemon -g（一旦更改代码就自动重启，不用手动重启了 -g 是global全局的意思）
		4. 安装mysql

## XSS
	Cross Site Scripting ：跨站脚本攻击
	跨站：我的网站，自然希望网站里面所有的逻辑都来自自己写的代码。如果我的网站运行了来自其他网站的脚本，就叫跨站。

![](https://i.imgur.com/7GoBQpj.png)

	这样一来人为的给网页一个脚本，一般来说只要是网页脚本能做的事情，xss注入的脚本都能做。
	1. 获取页面数据
	2. 获取Cookies
	3. 劫持前端逻辑（改变原有的逻辑）
	4. 发送请求（通过图片，form等方式发送到攻击者指定的网站）
	5. 偷取网站的用户数据
	6. 偷取网站任意数据
	7. 欺骗用户
	8. ......
	
	例如，我在QQ空间内一个说说内混杂了XSS，所有访问的我空间的看到那篇说说的人都会在不知情的情况下向我规定的地方发送我想要的数据

### XSS攻击分类
#### 反射型
	直接由url带过去的，页面直接显示这段代码
	写好url，再发给别人访问，以此获取访问者数据。
	但是可能网址很长，或者一眼能看出 网址包含的脚本，所以用长网址生成短网址这改一下
	https://dwz.cn/#/?_k=uu9n2n
#### 存储型
	XSS被保存在网站数据中，在其他用户访问的时候被其他用户执行
#### XSS攻击注入点
	1. HTML节点内容
		1. 标签内内容是由用户输入，动态生成的
	2. HTML属性
		1. 某个标签的属性是由用户输入，定义的
	3. JavaScript代码
		1. js代码中存在由后台注入的变量，或者用户的输入的数据，有可能导致js代码的逻辑改变
	4. 富文本
		1. 有各式的html文本
		2. qq空间发的说说这种就叫富文本
	例如：
		<img src="" /> 其中src是用户上传或者输入的
		这时，我们上传一个名为 1" onerror="alert(0) 的文件，这样原本的src就被替换成 <img src="1" onerror="alert(0)" />
	例如：
		js代码从后台拿用户数据，但是用户数据是XSS的脚本
		var data = "hello ";alert(1);"";
	例如：
		qq邮箱中，有文本编辑器，即为富文本。富文本传输的其实就是一堆复杂的html代码，也就是说可以人为的修改其原本想表达的东西
### 防御XSS
	1. 浏览器自动拦截
		当你的js参数出现在连接中，浏览器会进行自动拦截。
		但是防御极其有限，只能防御注入在html和属性中的部分XSS，而js中的和富文本中的并不能拦截
	2. 对文本中进行转义
		当XSS注入的时候，对 "<" 和 ">"进行转义，使之失去标签的作用 
			"<" 	——> &lt; 
			">" 	——> &gt;
		除此之外，html的属性需要 双引号，单引号，或者不需要引号，所以继续转义
			" " "	——> &quto;
			" ' "	——> &apos;
			" "		——> &#32;
	3. 对js从后台数据库提取的数据进行转义
		转义字符 或者 转换成 json
	4. 对于富文本设置 黑名单 或者 白名单
		黑名单：禁止某些属性或者标签的出现
			优点：好写，只需要进行正则
			缺点：html标签属性繁杂，一不小心就容易疏忽某些标签属性
		白名单：只允许某些标签或者属性的出现
			优点：完全防止禁用标签或者属性的出现
			缺点：不好写
### CSP
	Content Security Policy
	内容安全策略，用于指定哪些内容可执行
	
	CSP是http的头，规定了有哪些来源，可以限制	
	1. child-src(页面的自内容), connect-src(网络连接，如ajax), default-src(当其他没指定，就用default)
	2. font-src(字体), frame-src(框架), img-src(图片)
	3. manifest-src9Webapp的信息), media-src(视频音频), object-src(插件)
	4. script-src(脚本), style-src(css), worker-src(servers work等)

	定义了一些来源：
	1. <host-source>(host规定信任域名)<scheme-source>(根据信任协议判断是否信任) 'self'(同域可信任)
	2. 'unsage-inline'(指定是否信任直接插入页面的内容) 'unsafe-eval' (是否调用eval，函数)'none'(不信任任何内容)
	3. 'nonce-<base64-value>'(指定一个一次性的内容，) <hash-source>(后台定义hash表，前端计算跟hash相同的才会执行)
	4. 'strict-dynamic'(信任脚本之后，脚本新链接的网站或者其他脚本是否信任)
	
	基本格式：
	Content-security-Policy:default-src 'self' http://example.com;connect-src 'non1';
	Content-Security-Policy:connect-src http://example.com;script-src http://example.com/
	<meta http-equiv="Content-Srcurity-Policy" content="default-src https;">

## CSRF
	Cross Site Request Forgy
	跨站请求伪造
	例如：
		我在A网站登陆了A网站的账号，我打开了B网站，B网站有脚本可以让我在不知情的情况下对A网站进行了操作，比如获取隐私数据，转账等

### CSRF的运行顺序
	1. B网站向A网站
	2. 带A网站的Cookies
	3. 不访问A网站前端
	4. referer为B网站

### CSRF的特征
	1. 利用用户登陆态
	2. 用户不知情
	3. 完成业务请求
	4. ......

### CSRF的危害
	1. 盗取用户资金（转账，消费）
	2. 冒充用户发帖背锅
	3. 损害网站名誉
	4. ......

### CSRF的防御
#### 进制第三方网站带Cookies
	Cookies新带了 same-site属性，也就是说只有来自同一网站的请求才能带Cookies
	
	Cookies添加SameSite属性：
		SameSite = Strict：不允许任何链接带Cookies
		SameSite = Lax：允许部分带Cookies，但是像ajax这种不能带Cookies
		SameSite = true

#### 在前端页面加入验证信息
	既然CSRF不经过前端，那么设置一下，只有你经过前端才能访问到数据，那么也许可以拦截CSRF的攻击
	
##### 验证码
	通过图形验证码的方式，攻击者网站是无法知道随机的验证码是多少的
	缺点：
		1. 有局限性，毕竟不能给所有操作加上验证码
		2. 用户体验不好
##### token
	token是服务端生成的一串字符串，以作用户端进行请求的一个令牌，当第一次登陆之后，服务器生成一个token并将此返回给客户端。
	以后客户端只要带上这个token就行了，不需要带上用户密码
	
	提交的时候必须加上token信息才能生效，而只有经过前端才能获得token，也就是说通过这种方式可以防止第三方平台的不知情操作

#### 什么是referer
	上面 "CSRF的运行顺序" 中提到了referer是什么呢？
	referer是HTTP协议中的一个请求头，包含了请求时来自哪里的信息。
	所以CSRF中的referer中的请求位置时 攻击者 网站
	很容易的我们可以想到，验证请求位置是否是正常用户端来防止CSRF的发生
	其实 referer 的拼写应该是 referrer，所以这个是为数不多的错误拼写的单词

## 前端Cookies问题
	Cookies是什么？
	1. 它是一个前端数据的存储，它的存储是放在前端的。
	2. 后端可以通过http头设置Cookies的值。
	3. 请求时通过http头传给后端
	4. 前端也可以读写Cookies
	5. 遵守同源策略：当协议，域名，端口全部一致的时候才能读写
	
	前端只要通过 "document.cookie" 就可以取到Cookies了，追加可以直接 " document.cookie = "userId=2" "
	Cookies 可以修改原来的值，也能追加新的值，而且Cookies有自己的结构

### Cookies 的特性
	1. Cookies 有一个域名，表明在哪些地方可以使用
	2. Cookies 有一个有效期，表明在那段时间可以用
	3. Cookies 有一个路径，表明用在网络的哪一级，就像url层级一样
	4. Cookies 只能被http协议使用，即http-only
	5. secure 指定Cookies能否在 https中使用
	以上都可以在开发者工具中看到，可以通过js查看：
		document.cookie

	在 父路径中无法查看 子路径的Cookies
	例如：
		127.0.0.1:8080 界面无法看到 127.0.0.1:8080/user/login 中的Cookies，但反过来就可以

	Cookies没有删除方法，想删除Cookies只有设置Cookies的有效期为过去的时间，才能删除Cookies


### Cookies作用
	1. 存储个性化设置
		1. 用户在我的网站用的什么皮肤
		2. 用户上次浏览到那个界面
		3. 某个菜单是打开还是关闭
	2. 存储未登录时用户唯一标识
	3. 存储已登录用户的凭证
	4. 存储其他业务数据
#### Cookies-登陆用户凭证
	1. 前端提交用户名和密码
	2. 后端验证用户名和密码
	3. 后端设置http头，设置用户凭证
		1. 用户ID（不安全，容易被篡改）
		2. 用户ID+签名（签命通过自己的算法算出，安全性高）
		3. SessionID（随机的字符串）

### Cookies 和 CSS的关系
	XSS可能偷取Cookies
	http-only的Cookies有几率避免Cookies被盗
### Cookies 和 CSRF的关系
	CSRF利用了用户的Cookies发送数据等
	但是攻击站点无法读写Cookies
	最好能阻止第三方使用Cookies

### Cookies-安全策略
	1. 加签命放篡改（数据是明文，只是验证有没有被修改）
	2. 私有变换（加密）
	3. http-only（防止XSS）
	4. secure
	5. same-site

## 点击劫持
	操作是用户完成，但是并不是用于自主意愿完成的
	通过用户的点击完成某个操作，但是用户并不知情。
	例如：
		用户登录网站A，此时打开网站B，在网站B上的点击操作，实际上应用在的网站A中
		B网站里面其实是一个<iframe>，将A网站的架构放在了<iframe>中，然后通过设置opcity来隐藏这个<iframe>，再然后就给<body>一个背景贴图
		贴图中有按钮样子的图片，也有其他的图片，混淆视听，当用于点击贴图中的图片的时候，其实点的是<iframe>中的按钮

### 点击劫持的特征
	1. 用户亲手操作
	2. 用户不知情
	3. ......
### 点击劫持的危害
	1. 盗取用户资金（转账，消费）
	2. 获取用户敏感信息
	3. ......

### 点击劫持的防御
	点击劫持攻击的前提是 通过<iframe>将目标网站嵌套到自己网站
#### 用Javascript禁止内嵌
	在js中，如果没有内嵌那么 top === window
	如果被内嵌了，top 并不是 === window，<iframe>中的window就是<iframe>的window 但是 top 指的是 <body>的window
	

	if(top.location != window.location){  
		top.location = window.location  
	}
	通过上面的代码，窗口会进行跳转，跳转到<iframe>的界面，也就是原界面
	但是 <iframe>中，有一个sandbox属性来限制<iframe>的功能，例如禁掉js的能力，所以js并不能百分百解决点击劫持
#### X-FRAME-OPTIONS 直接禁止内嵌
	ctx.set('X-FRAME-OPTIONS', 'DEMY');
	DENY			禁止内嵌
	SAME-ORIGIN		同一个网站可以使用
	SAMEORIIN		嵌入页和被嵌入页在同一域下
	ALLOW-FROM+网站	允许指定网址内嵌

#### 其他辅助手段
	1. 验证码
	2. ......
	
## HTTP传输窃听
	HTTP是一个明文协议，也就是说不会对数据进行加密
	客户端和服务器的发送都是明文的
	而数据包会经过很多中间节点，而这些节点愿意的话可以修改这些数据

![](https://i.imgur.com/fk6k3FK.png)

	1. 窃听
		开启服务器代理，http请求可以直接查看文件请求头，响应头，响应body。
	2. 篡改
		在代理软件中，修改资源文件为我电脑中的资源文件，那么在客户端看到或显示的我的资源

### 窃听和篡改
	窃听：你传输过程中的所有数据可以直接被别人看到
	1. 窃听用户密码
	2. 切丁患处敏感信息
	3. 非法获取个人资料
	
	篡改：在传输过程中，修改或者插入信息
	1. 插入广告
	2. 重定向网站
	3. 无法防御的XSS和CSRF攻击（如果修改了html或者js，那么我们做的防御没有任何意义）

### HTTPS
	HTTP协议是明文协议，中间方就可以直接查看篡改。
	HTTPS TLS(SSL)加密 在 传输层加密
	TLS 就是 SSL，现在称之为TLS，以前是SSL

### 中间人攻击
	中间人对客户端来说是服务器，对服务器来说是客户端，它是一个伪装的设备
	也就是说，中间人可以查看客户端与服务器之间的通信，而不受TLS加密的影响
### 确认服务器身份
	CA：数字证书中心
	
![](https://i.imgur.com/24cItvo.png)
	
	保证安全的点：
	1. 证书无法被伪造
	2. 证书私钥不被泄露（恶意攻击者盗用私钥，可以查看篡改）
	3. 域名管理权不能泄露（一旦泄露，被恶意攻击者指向自己的服务器，证书就会给攻击者的服务器而不给你）
	4. CA坚守原则（验证不通过，不给证书）

## 密码安全
### 密码的作用
	"证明你是你"，说白了就是证明一下登陆操作的人是合法用户
	原理很简单，就是申请账号的时候是你最开始设置的密码和你现在使用的密码相同，对比一下就是了
### 密码泄露渠道
	1. 数据库被偷
	2. 服务器被入侵
	3. 通讯过程被窃听
	4. 内部人员泄露数据
	5. 其他网站（撞库，A网站的数据泄露，攻击者拿着用户的密码试用户在其他网站的密码）
	6. ......
### 密码存储
	1. 严禁密码的明文存储（防泄露，数据库中存储不用明文，加密）
	2. 单向变换（一个密码对应一个密文）
	3. 变化复杂度要求（防猜解）
	4. 密码复杂度要求（防猜解）
	5. 加盐（放猜解）
#### 哈希算法——信息摘要算法
	明文-密文 	一一对应
	雪崩效应 	只要明文有一点不一样，密文完全不一样
	密文-明文	无法反推
	密文固定长度	一般来说32为字符串
	常见哈希算法	md5, sha1, sha256
#### 密码单项变化彩虹表
	以md5为例，先暴力出所有的可能的明文的密文，然后根据窃听得到的密文去反过来查明文。这样子存着所有结果的密文表就被成为彩虹表

	1. 混合加密
		但是我们可以 混合多种加密算法，例如：
			md5(明文) = 密文
			md5(md5(明文)) = 密文
			md2(sha1(明文)) = 密文
			md5(sha256(sha1(明文))) = 密文
		这样子就算是查彩虹表，最后得到的可能很难是正确的

	2. 复杂密码
		虽然可以用算密文反过去映射明文，但是位数越多，越复杂的密码，破解所需的时间和内存就越大，一个20为的密码需要900G的硬盘来存储密码

### 加盐
	md5（ID + 原始密码 + 盐（随机生成的字符串） + 固定随机串（服务器一开始就定义的不变的字符串）*N个（顺序随意））= 最终密码
	就是自动的给原始密码一个复杂的字符串，让其安全
	
### 密码变化次数越安全
	1. 加密成本几乎不变（生成密码时速度慢一些，但是只生成一次）
		1. 对使用者来说，这点时间几乎是小事
		2. 对解密者来说，破解时间成倍增加
	2. 彩虹表失效（数量太大，无法建立链接）
	3. 解密成本增加N倍

### 密码传输的安全性
	1. https传输
	2. 频率限制（限制固定时间内只能登陆多少次）
	3. 前端加密意义有限（传输层窃听并不知道明文密码，但是攻击者也可以传输你传输的密文）

### 生物特征密码
	1. 指纹（唇纹）
	2. 声纹
	3. 虹膜
	4. 人脸
#### 缺陷
	1. 私密性-容易泄露（指纹随时可以提取，圣文也是，人脸也是）
	2. 安全性-碰撞（可能出现识别错误）
	3. 唯一性-终身唯一 无法修改（如果别人获取了你的密码，你不能去改你的指纹密码对吧）

## 接入层注入问题
### 关系型数据库
	1. 存放结构化数据
	2. 可搞笑操作大量数据（维护，查询）
	3. 方便处理数据之间的关联关系
	4. 常见的：access/sqlite/mysql/mssql server

### SQL语言
	数据库查询语言
	1. 被广泛接受的语言，各大数据库都能接受，已经被标准化
	2. 但是标准话并不代表完全语言，每个数据库的SQL都有一点不一样
	3. 类似自然语言
	4. 用于关系型数据库

### SQL注入
	在web中，数据库操作都是通过事先定义的代码实现的，毕竟用户不可能直接操作数据库
	例如：
		select * from table where id = ${id};
	
#### 什么是注入
	如果用户传入的是一个 " 1 or 1 = 1 "，这个是一个id
	但是插入到sql中变成了：
		select * from table where id = 1 or 1 = 1;	
	类似于XSS，去用传入的数据修改原本的逻辑结构
	例如：
		select * from user where username = '${data.username}' and password = '${data.password}'
	这个时候，用户传入的是 "username" "1' or '1'='1"
	那么原本的查询语句就变成了：
		select * from user where username='username' and password = '1'or'1'='1'
	那么很容易发现， " or "这个关键字 否认了前面所有的判断，导致攻击者随便找个账户都能登陆

#### 注入方法
	1. 在网址后加上 " and 1=1 "网页不会产生变化
	2. 但是加上 " and 1=0 "	网页就变化报错了，通过这个可以检查是否有sql注入的危险
	3. 或者插入 " or 1=1 "访问一些当前用户没有权限访问的页面
	4. 同理通过 "and union(version(), 1, 1)=6"来判断数据库的版本位数第一位是否是6，这种方式获得数据库信息
	5. 知道数据库的信息，可以查看该版数据库的漏洞
	6. 还有通过其他的sql语句可以探测到 数据库的字段，例如ID，password是否存在，来推测表的结构
	7. 这里只介绍了很小很小的一部分，还有很多可以去搜索

#### sql注入的危害
	1. 猜解密码（用工具很快）
	2. 获取数据（信息泄露）
	3. 删库删表
	4. 拖库
	5. ......

#### SQL注入防御
	1. 关闭错误输出
		1. 攻击者通过错误输出信息来判断注入方向是否正确
	2. 检查数据类型
		例如： 120.0.0.1/post/10中10是页面的id
		但是 攻击者通过 120.0.0.1/post/100 or 1=1来随机的查看页面
		这个时候只要判断后面的值是否是数字，就能判断出是否是攻击者，我们只接收前面的10，不接受后面的字符串
	3. 对数据进行转义（escape()模块）
		因为上面只是简单的id，但是有的时候搜索需要字符，所以不能一棒子打死
		对于某些情况，可以通过转义来限制用户输入的意思，防止注入语句
	4. 使用参数化查询（需要安装mysql2）
		先告诉数据库，我要传一个id，你帮我找一下
		再传一个id过去，不管这个id是什么，数据库只会查找id而不会执行这个id
		先给个意图，再给参数
		npm install mysql2 --save
	5. 使用ORM（对象关系映射）
		把数据库的数据，通过代码的对象映射出来，一个对象就是一个记录
		一般语言都有人写好了ORM
		npm install sequelize --save（node.js的ORM）

#### NoSQL
	非关系型数据库，不同于sql，一定程度上可以防御sql注入
	但是也是可以sql注入的
##### 防御方式
	1. 检查数据类型
	2. 类型转换
	3. 写完整条件

## 接入层上传问题

### 上传问题
	1. 上传文件
	2. 再次访问上传的文件
	3. 上传的文件被当成程序解析
	如果上传的文件只是图片，音频就还行，但是如果是可执行文件就会出现大问题，因为攻击者的逻辑会被执行

	所以需要判断上传文件的后缀等，防止不符合要求的文件上传

## 社会工程学
### 信息泄露
	1. 泄露系统敏感信息
	2. 泄露用户敏感信息
	3. 泄露用户密码

### 信息泄露的途径
	1. 错误信息失控
	2. sql注入
	3. 水平权限控制不当
	4. XSS/CSRF
	5. 快递单/房产中介
	6. ......
### 社会工程学
	通过渠道挖出你的个人信息

![](https://i.imgur.com/KFpGqX6.png)

	仅仅通过你的昵称，查出你的姓名，进而查到更多隐私信息，然后建立出一个个人数据模型
	你的身份由你掌握的资料确定，当你的个人信息被别人掌握，别人就可以伪装成你的身份，然后用你的身份去做坏事

### 社会工程学案例
#### 电信诈骗（徐玉玉案件）
	为什么会出现电信诈骗，因为骗子通过掌握的关于你的信息去获取你的信任
	高考录取之后，成绩公示，报纸公示，让徐玉玉的个人信息被不法分子获取，并且利用这些信息进行诈骗
#### 伪装公检法
	处于对公检法的信任，外加对方可以报出你的个人信息，甚至一些私人信息，你不会怀疑对方
#### QQ视频借钱
	伪装好友，发送QQ视频，由于信息泄露可以获取一个人的视频，声音
#### 微信伪装好友
	就算一开始你不信，但是久而久之你就以为她是你的好友

### OAuth思想
	即 现在网站的 授权登陆 的思想

![](https://i.imgur.com/fIstJMH.png)
`access Token为每个用户对应的那一个Token，所以每次查询，只能查一个人，一定范围内保护用户资料`

	特点：
	1. 一切行为由用户授权
	2. 授权行为不泄露敏感信息
	3. 授权会过期

### 利用OAuth思想防止资料泄露

![](https://i.imgur.com/lJ3UsPM.png)

	1. 用户授权读取票据
	2. 无授权的资料不能读取（防止一个人查询其他人的资料）
	3. 不允许批量获取数据、
	4. 数据接口可风控审计（获取查询数据的时间，位置等）

## 其他安全问题
### 拒绝服务 DOS
	模拟正常用户访问网站，但是访问量成千上万甚至过亿，来占用服务器大量的资源，以至于网站不能正常打开访问
#### 攻击方式
	1. TCP半连接
		TCP的三次握手，我们只发送第一次请求，让服务器处于准备好并等待我们第三次握手的状态，这个时候就会影响服务器工作
	2. HTTP链接
	3. DNS
		当TCP和HTTP的潮水攻击都被防下来的时候，转而攻击你的DNS（域名解析服务器）

#### 大范围分布式拒绝服务攻击DDOS
	在DOS的基础上，用大范围的机器攻击网站服务器
	1. 流量可达几十到上百G
	2. 分布式（肉鸡，代理）
	3. 极难防御（无法辨别正常用户和恶意用户）

#### DOS攻击防御
	1. 防火墙（防火墙有办法尝试过滤恶意流量）
	2. 交换机，路由器（只能防护小范围）
	3. 流量清洗（对流量进行分析，找出特征，分辨正常访问）
	4. 高防IP（云服务提供的，当面对DOS攻击时，把IP转为服务器提供商提供的另一个IP，而另一个IP拥有大规模的流量清洗服务）
	5. 编写代码时 避免重逻辑业务
	6. 快速失败快速返回
	7. 防雪崩机制
	8. 有损服务
	9. CDN（静态网页发送到CDN上，减少服务器的压力）

### 重放攻击
	请求被窃听或记录，再次发送相同的请求，产生意外的结果
	例如：
	1. 用户被多次消费
	2. 用户登陆态被盗取（重新发送之后，伪装成原用户）
	3. 多次抽奖

#### 重放冲击防御
	1. 加密（HTTPS）
	2. 请求加时间戳（防止二次发送）
	3. 加上token（session，每次发送的token都会变化，那么同样的请求 token就会很容易识别出来）
	4. nonce（num+once，是只用一次的数字，就像ID一样）
	5. 数字签名