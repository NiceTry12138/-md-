---
title: 算法训练板子
date: 2019-01-26 20:59:01
tags:
---


# 题目1

## 正题
经过了选号和漫长的等待，处女座终于拿到了给小姐姐定制的手环，小姐姐看到以后直呼666！

处女座其实也挺喜欢6这个数字的，实际上他做手环的时候选取的k=6。
所以他对于包含数码6的数字极其敏感。
每次看到像4567这样的数字的时候他的心就像触电了一样，想起了小姐姐。

现在你要给处女座展示一系列数字，你想知道他的内心会激动多少次。对于同一个数字，
他最多只会激动一次，即如果这个数是66666，他还是只会激动一次。

## 输入描述:
一行包括两个数字l,r，表示你给处女座展示的数字范围为[l,r]。
输出描述:
一行一个整数，表示处女座内心激动的次数。

## 示例1
输入  
10 20  
输出  
1

```cpp
#include<iostream>
using namespace std;
typedef long long LL;
LL l,r;
bool check(LL x){
    while(x>0){
        if(x%10==6) return true;
        x/=10;
    }
    return false;
}
LL solve(LL x){
    if(x<=0) return 0;
    int cnt=0;
    for(LL i=x/10*10;i<=x;i++)
        if(check(i)) cnt++;
    return solve(x/10-1)*9+cnt+x/10;
}
int main(){
    cin>>l>>r;
    cout<<solve(r)-solve(l-1);
}
```

# 题目2

## 正题
处女座放完了"高利贷"，拿到了不少的资金，又可以和小姐姐约会啦！（之前不还是攒钱打比赛的吗）现在处女座拿到了一份宁波市旅游地图决定和小姐姐一起去玩耍。他们来到了动物园，去参观里面的动物。但是很不幸的是，他们在游玩的途中遇到了一只恶龙。

恶龙长有n个头，但经过了处女座的调教，恶龙变得善良了一些。它的n个头每个头要么仍是邪恶的头，用“1”表示，要么已经变得善良，用“0”表示，因而恶龙的n个头就可以用n位01串来表示。而此时处女座要发挥自己的勇士形象，要把所有的龙头都变成
0000
⋯
00
0000⋯00完全善良的龙头。每一次，他可以砍掉龙最右侧的一个头，同时龙会在最左侧长出新的一个头，以保证龙头数量不变。如果他砍掉的是一个1，即邪恶的头，他可以决定龙在最左侧会长出什么样的头；但如果他砍掉了一个善良的头，那么玻璃心的恶龙将会在左侧不受控制的长出一个随机的头，既可能是善良的头，也可能是邪恶的头，而且它总会与处女座作对，尽力的破坏他的计划。

现在给你一个恶龙头的初始状态，即一个01串，请帮助处女座判断一下，能否在有限步之内让全部的龙头都变成善良的龙头。
输入描述:
输入第一行T，表示用例组数。

之后T行，每行一个01串S表示龙头的初始状态，“0”表示善良的头，“1”表示邪恶的头。

## 输出描述:
对于每组数据，处女座能否将全部的龙头变成善良的头，可以的话输出“cnznb”，不可以则输出“ljcnz”（不含引号）。  
示例1    
输入  
1  
1111  
输出  
cnznb  

```cpp
#include<cstdio>
int main()
{
    int t;scanf("%d",&t);
    while(t--)
    puts("cnznb");
}
```

# 题目3

## 正题
处女座靠着自己的家教本领赚够了去比赛的钱，于是开启了疯狂训练。在每个夜深人静第二天不收作业的夜晚，他都会开始刷题。

"今日又是一个刷题的夜晚。"他挑选了n道题开始刷，而题太多，刷不掉，理还乱（呜呜）、自己没有解决的题目每分钟都会给他带来
b
i
bi的疲倦值，而解决每一道题目都需要花费
a
i
ai分钟的时间。

当然，处女座一般都是考虑清楚了再写题的，所以他在写题的时候都会精神抖擞，也就是说，当前正在写的那一题并不会给他带来任何疲劳。

为了迎接后天要收的作业和明天要遇到的小姐姐，他想让今晚的刷题尽可能的轻松，那请你帮他找出最小所需要的疲倦值吧。

## 输入描述:

输入数据共包括n+1行，第一行包括一个n表示处女座今晚打算训练的题的数量。

接下来n行，每行包括两个整数ai,bi，分别表示处女座刷掉本题要花费的时间和本题每分钟会带来的疲倦值。  
输出描述:   
一行包括一个整数，表示处女座今晚训练会产生的最小疲倦值。  
示例1  
输入   
6  
6 1  
4 5  
4 3  
6 2  
8 1  
2 6  
输出  
86   

## 说明  
先做第6个题，增加（1+5+3+2+1）*2= 24 点疲倦值，再做第2个题，增加28点疲倦值，随后依次是第3,4,1,5道题，增加16,12,6点疲倦值。总共的疲倦值是24 + 28 + 16 + 12 + 6 = 86点。

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
 
typedef long long ll;
 
ll c;
struct A {
    ll a,b;
    bool operator<(A t){
        return a*t.b<b*t.a;
    }
    A(){
        cin>>a>>b;c+=b;
    }
};
 
int main(){
    c=0;
    ll n,m=0;cin>>n;A da[n];
    sort(da,da+n);
    for(int i=0;i<n;++i){
        m+=(c-da[i].b)*da[i].a;
        c-=da[i].b;
    }
    cout<<m;
}
```

# 题目4
## 输入描述
输入描述:
仅一行三个整数 f1,f2,a,分别表示两只手产生的力的大小以及它们之间的夹角。
输出描述:
输出一个实数表示两力合力的大小，要求相对误差或绝对误差不超过 10^−6

示例1
输入
复制
6 8 90
输出
复制
10.0000000000
示例2
输入
复制
10 10 60
输出
复制
17.3205080757

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#define PI 3.14159265
using namespace std;
int main(){
    int f1, f2;
    int r;
    cin >> f1 >> f2 >> r;
    double r1 = cos(r * PI / 180.0 );
    printf("%.10lf", sqrt(f1*f1*1.0 + f2*f2*1.0 + 2*f1*f2*r1));
    return 0;
}
```